/*
    - form of IPC
    - notification to a process indicating occurrence of an event
    - way to communicate information to a process about state of other process, the OS, and hardware.
    - generated by system or user can do it programmatically.
    - when signal sent, OS interrupts process' normal flow to deliver the signal.
        - process has to deal with signal immediately (can ignore)
    - process can recieve signal asynchronously (at any time)
    - fix set of signal - just a short message that contains an integer
        - SIGHUP | 1 | Term | hangup detected on controlling terminal or death of controlling process
        - SIGINT | 2 | Term | interrupt from keyboard (ctrl-c)
        - SIGQUIT | 3 | Core | quit instruction
        - SIGILL | 4 | Core | Illegal instruction
        - SIGABRT | 6 | Core | Abort signal from abort(3)
        - SIGFPE | 8 | Core | Floating point exception
        - SIGKILL | 9 | Term | Kill signal
        - SIGSEGB | 11 | Core | Invalid memory reference, segmentation fault√ü
        - SIGKILL | 13 | Term | Broken pipe: write to pipe with no readers
        - SIGTSTP (ctrl-z)
        - SIGCONT (fg/bg)
        - SIGTERM terminate program
        - other signal events: illegal instructions, segmentation violations, termination orders, when using fgets()
    - when signal raised, default actions performed. each signal has name, value, default action 
        - Term - process will terminate
        - Core - process will terminate and produce core dump file
        - Ign - process ignores signal
        - Stop - process stops like ctr-z
        - Cont - process will continue from being stopped
*/

/*
raising a signal
    - can be generated using:
        - raise() sends signal to current process
            -int raise(int sig)
                - if successful signal specified in sig is generated
                - if not, raise() returns non-zero value
            - can only send signal to program that contains it
            - cannot send signal to other processes
        - kill() sends signal to specific process

    - possible to catch almost all signals in program
        - sometimes need to run own code when recieving signal (handle/catch)
        - maybe need to do cleanup before terminating
        - possible to ignore almost all signals apart from a few: SIGKILL, SIGABRT, SIGSTOP
        - actions for signals are: default action, handle signal, ignore signal
        - after the signal handler is called once it ownt be called again so needs to be reinitialised
        - can catch handle usin signal.h
            - 2 ways: signal() and sigaction()
                - signal() used to tell OS which function it should call when signal is sent to a process
                    - function used to deal with or handle a signal that is sent to it
                    - if you have foo() that you want OS to call when interript signal send to process then
                      need to pass function name foo to signal function as parameteter
                        - foo() is called the handler
                    - handlers are short/fast code, do just enough to deal with signal
                    - recieves 2 arguments, integer signal number and pointer to signal handling function
                    - returns
                        - on success: return address of void function that takes an integer argument
                        - on error: returns SIG_ERR
                    - typedef void (*sighandler_t) (int); sighandler_t signal(int signum, sighandler_t handler)
                        - signal() will call registered handler
                        - handler can be either: SIG_IGN (ignore signal); SIG_DFL (setting signal back to default mechanism); user defined handler
                - sigaction() used to tell OS which function it should call when a signal is sent to a process
                    - function handles the signal
                    - essentially a function wrapper; a struct that contains a pointer to a function
                    - if you have foo() that you want O to call, you wrap foo() up as sigaction
                        - foo() is called the handler
                    - int sigaction(int signum, const struct sigaction *newaction, struct sigaction *oldaction); 3 params
                        - signal number: integer value of signal you want to handle
                        - new action: address of sigaction you want to register
                        - old action: if passing pointer to another sigaction, will be filled with details of current handler you are about to replace
                                      else  if you don't care about existing signal handler can set to NULL
                        - returns -1 if fails and will set errno variable
                        - struct inside sigaction contains:
                            - field 1: handler mentioned either in sa_handler or sa_sigaction
                                - void (*sa_handler)(int); //which handler to call based off of which int
                                    - handler fo sa_handler specifies action to be performed based on signum
                                        - SIG_DFL indicating default action
                                        - SIG_IGN to ignore signal or pointer 
                                - void (sa_sigaction)(int, siginfo_t *, void*)
                                    - handler for sa_sigaction 
                                        - specifies signal number as first argument
                                        - specifies pointer to siginfo_t structure as the second argument  
                                            - this contains signal information such as signal number to be delivered, signal value,
                                              process ID, real user ID of sending process
                                        - specifies pointer to user content as third argument
                            - field 2: set of signals to be blocked
                                - int sa_mask; variable specifies mask of signals that should be blocked during execution of signal handler
                            - field 3: field specifies set of flags which mody behaviour of the signal
                                - int sa_flag
                            - field 4: restore handler
                                - void (*sa_restorer) (void); returns 0 on success, and -1 for failure


                
raising an alarm
    - mechanism for a process to interrupt itself in the future
    - alarm() sets a timer
        - when timer expires, process receives a signal (SIGALARM)
    - only one alarm clock per process
    will return a value if another alarm has been set

*/


#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void handler_dividebyszero(int signum);


int main(){
    // printf("Testing SIGSTOP-----\n");
    // raise (SIGSTOP);
    // printf("I am after SIGSTOP---\n");
    // return 0;

    // alarm(5);//sends signal in future to terminal program so for loop terminated after 5 seconds
    // for(int i=1; i<10; i+=1){
    //     printf("%d\n", i);
    //     sleep(1);
    // }

    int result = 0;
    int v1, v2;
    void (*sigHandlerReturn)(int); //function pointer
    sigHandlerReturn = signal(SIGFPE, handler_dividebyszero);//returns value handler else SIG_ERR returned
    // sigHandlerReturn = signal(SIGFPE, SIG_IGN);
    
    if (sigHandlerReturn == SIG_ERR){
        perror("Signal error: ");
        return 1;
    }

    v1 = 121;
    v2 = 0;
    result = v1/v2; //error bc dividing by 0;
    printf("result is %d\n", result);
    return 0;


}   

void handler_dividebyszero(int signum){
    printf("signal is %d\n", signum);
    if (signum == SIGFPE){
        printf("Recieved SIGFPE, divided by zero exception");
        exit(0);
    }else{
        printf("Recieved %d Signal \n", signum);
    }
}