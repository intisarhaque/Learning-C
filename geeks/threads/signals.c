/*
    - form of IPC
    - notification to a process indicating occurrence of an event
    - way to communicate information to a process about state of other process, the OS, and hardware.
    - generated by system or user can do it programmatically.
    - when signal sent, OS interrupts process' normal flow to deliver the signal.
        - process has to deal with signal immediately (can ignore)
    - process can recieve signal asynchronously (at any time)
    - fix set of signal - just a short message that contains an integer
        - SIGHUP | 1 | Term | hangup detected on controlling terminal or death of controlling process
        - SIGINT | 2 | Term | interrupt from keyboard (ctrl-c)
        - SIGQUIT | 3 | Core | quit instruction
        - SIGILL | 4 | Core | Illegal instruction
        - SIGABRT | 6 | Core | Abort signal from abort(3)
        - SIGFPE | 8 | Core | Floating point exception
        - SIGKILL | 9 | Term | Kill signal
        - SIGSEGB | 11 | Core | Invalid memory reference
        - SIGKILL | 13 | Term | Broken pipe: write to pipe wiht no readers
        - SIGTSTP (ctrl-z)
        - SIGCONT (fg/bg)
        - SIGTERM terminate program
        - other signal events: illegal instructions, segmentation violations, termination orders, when using fgets()
    - when signal raised, default actions performed. each signal has name, value, default action 
        - Term - process will terminate
        - Core - process will terminate and produce core dump file
        - Ign - process ignores signal
        - Stop - process stops like ctr-z
        - Cont - process will continue from being stopped
*/

/*
raising a signal
    - can be generated using:
        - raise() sends signal to current process
            -int raise(int sig)
                - if successful signal specified in sig is generated
                - if not, raise() returns non-zero value
            - can only send signal to program that contains it
            - cannot send signal to other processes
        - kill() sends signal to specific process

    - possible to catch almost all signals in program
        - sometimes need to run own code when recieving signal (handle/catch)
        - maybe need to do cleanup before terminating
        - possible to ignore almost all signals apart from a few: SIGKILL, SIGABRT, SIGSTOP
        - actions for signals are: default action, handle signal, ignore signal
        - can catch handle usin signal.h
            - 2 ways: signal() and sigaction()
                - signal() used to tell OS which function it should call when signal is sent to a process
                    - function used to deal with or handle a signal that is sent to it
                    - if you have foo() that you want OS to call when interript signal send to process then
                      need to pass function name foo to signal function as parameteter
                        - foo() is called the handler
                    - handlers are short/fast code, do just enough to deal with signal
                    - recieves 2 arguments, integer signal number and pointer to signal handling function
                    - returns
                        - on success: return address of void function that takes an integer argument
                        - on error: returns SIG_ERR
                    - typedef void (*sighandler_t) (int); sighandler_t signal(int signum, sighandler_t handler)
                        - signal() will call registered handler
                        - handler can be either: SIG_IGN (ignore signal); SIG_DFL (setting signal back to default mechanism); user defined handler
                - sigaction()

                
raising an alarm
    - mechanism for a process to interrupt itself in the future
    - alarm() sets a timer
        - when timer expires, process receives a signal (SIGALARM)
    - only one alarm clock per process
    will return a value if another alarm has been set

*/


#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void handler_dividebyszero(int signum);


int main(){
    // printf("Testing SIGSTOP-----\n");
    // raise (SIGSTOP);
    // printf("I am after SIGSTOP---\n");
    // return 0;

    // alarm(5);//sends signal in future to terminal program so for loop terminated after 5 seconds
    // for(int i=1; i<10; i+=1){
    //     printf("%d\n", i);
    //     sleep(1);
    // }

    int result = 0;
    int v1, v2;
    void (*sigHandlerReturn)(int); //function pointer
    sigHandlerReturn = signal(SIGFPE, handler_dividebyszero);//returns value handler else SIG_ERR returned
    // sigHandlerReturn = signal(SIGFPE, SIG_IGN);
    
    if (sigHandlerReturn == SIG_ERR){
        perror("Signal error: ");
        return 1;
    }

    v1 = 121;
    v2 = 0;
    result = v1/v2; //error bc dividing by 0;
    printf("result is %d\n", result);
    return 0;


}   

void handler_dividebyszero(int signum){
    printf("signal is %d\n", signum);
    if (signum == SIGFPE){
        printf("Recieved SIGFPE, divided by zero exception");
        exit(0);
    }else{
        printf("Recieved %d Signal \n", signum);
    }
}